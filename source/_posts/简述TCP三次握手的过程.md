---
title: 简述TCP三次握手的过程
date: 2020-07-05 16:52:29
tags:
---
## TCP包头作用

#### 序号：

###### Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记

#### 确认号：

###### Ack序号，占32位，只有Ack标志位为1时，确认序号字段才有效，Ack=Seq=1

#### 标志位:
<!-- more -->
###### 共6个,即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下；

- URG：紧急指针有效
- ==ACK==：确认序号有效
- PSH：接收方应该尽快将这个报文交给应用层
- RST：重置连接
- ==SYN==：发起一个新连接
- ==FIN==：释放一个连接

## 三次握手
> 三次握手的本质是确认通信双方收发数据的能力
> 
> 首先，我让信使运输一份信件给对方，对方收到了，那么他就知道了我的发件能力和他的收件能力是可以的。
> 
> 于是他给我回信，我若收到了，我便知我的发件能力和他的收件能力是可以的，并且他的发件能力和我的收件能力是可以。
> 
> 然而此时他还不知道他的发件能力和我的收件能力到底可不可以，于是我最后回馈一次，他若收到了，他便清楚了他的发件能力和我的收件能力是可以的。
> 
> 这，就是三次握手，这样说，你理解了吗？

## 上面是通俗的表达，下方高能注意护眼模式：

- 第一次握手：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号seq，那客户端向服务端发送的报文段包含SYN标志位(也就是SYN=1)，序列号seq=100。客户端进入SYN_SENT状态，等待服务端确认。
- 第二次握手：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=300、确认号ack=101(客户端发过来的序列号+1)。服务端进入SYN_RCVD状态
- 第三次握手：客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是不携带数据的ACK报文是不占据序列号的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。

---
#### 类似面试题

- 简述TCP包头的内容？
    ###### 主要几个内容：源端口、目的端口、序列号Seq、确认号Ack、标志位、校验和、数据
- 简述TCP四次挥手的过程？
    ###### 第一次挥手：客户端发送一个标志位为FIN包，Seq序号=m，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态。
    ###### 第二次挥手：服务端收到标志位FIN包后，发送一个标志位ACK给客户端，Ack确认序号为m+1，服务端进入CLOSE_WAIT状态。
    ###### 第三次挥手：服务端发送一个标志位FIN=1,ACK=1,Seq序号=n，Ack确认号为m+1，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态。
    ###### 第四次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK标志给服务端，Ack确认序号=n+1，服务端进入CLOSED状态，完成四次挥手
